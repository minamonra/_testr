Продолжим. main.c: #include <string.h>
#include "cp1251_chars.h"
#include "common.h"
#include "dispmt16s.h"
#include "buttons.h"
#include "eeprom.h"
#include "rs485.h"
#define PULTVERSION "ver.3.4.ep3d"

// Режимы работы дисплея
typedef enum {
    DNORMMODE    = 0, // Нормальный режим
    DEDITMODE    = 1, // Режим редактирования
    SHOWMSG      = 2, // Режим показа сообщений
    DBRIGHTMODE  = 3, // Режим настройки яркости
    DSETUPMODE   = 4, // Режим настройки
    DSCREENSAVER = 5  // Режим скринсейвера
} display_mode_t;

// Коды ошибок
typedef enum {
    ERR_OK = 0,
    ERR_READ = -1,
    ERR_OUT = -2
} error_code_t;

#define MSGSHOWTNS            600 // Время показа сообщения в миллисекундах
#define EDIT_TIMEOUT_MS     50000 // Таймаут редактирования
#define NORMMODE_TIMEOUT_MS 50000 // Таймаут бездействия в нормальном режиме

// Адреса в EEPROM
#define EEBRIGHTNESS   1   // Ячейка для хранения яркости
#define EELASTUSEDCELL 2   // Ячейка с последним выбранным индексом
#define EEFIRSTTIMERUN 3   // Ячейка инициализации EEPROM, первый запуск там 0xFF, после = 0x00
#define EENEED2SAVEON  4   // Задумана как нужность сохранения в памяти панели последнего посланного текста

// Параметры редактирования
#define EDTSTRLEN        17  // Длина редактируемой строки для отображения (16 символов + терминатор)
#define EDTMODMAXCNT     55  // Максимальное значение для режима редактирования
#define MAXCELLEEPROMUSE 50  // Максимальное количество ячеек EEPROM
#define MAX_BRIGHTNESS   9   // Максимальная яркость

// Глобальные переменные состояния
volatile uint8_t selected_index_enc            = 0;
volatile uint8_t max_selected_index_enc        = MAXCELLEEPROMUSE;
volatile uint32_t ttms                         = 0;
volatile uint32_t lcdms                        = 0;
volatile display_mode_t display_mode           = DNORMMODE;
volatile uint8_t symbol_position               = 0;
volatile uint8_t current_sell_ed               = 0;
volatile uint8_t brightness                    = 5;
volatile uint8_t last_show_editing_cell        = 0;
volatile uint32_t last_edit_activity_time      = 0;
volatile uint32_t last_norm_mode_activity_time = 0;
volatile uint32_t last_bright_activity_time    = 0;
volatile uint8_t display_part                  = 0; // 0 - первая часть строки, 1 - вторая часть
volatile uint8_t editing_part                  = 0; // 0 - редактируем первую часть, 1 - редактируем вторую часть

// Буферы для строк - увеличены для работы с 32-символьными строками из EEPROM
char editing_string[33] = {0};  // 32 символа + терминатор
char display_string[33] = {0};  // 32 символа + терминатор
char new_char           = 0x20;
char msg_text[32]       = {0};

// Переменные для управления сообщениями
volatile uint32_t msg_start_time = 0;
volatile uint8_t msg_active      = 0;

// Коллбек функция для обработки вращения энкодера
void (*encoder_callback)(uint8_t new_value, int8_t direction) = 0;

// Структура для кэширования данных EEPROM
typedef struct {
    uint8_t index;
    char data[33];  // Увеличено до 32 символов + терминатор
    uint8_t valid;
} eeprom_cache_t;

static eeprom_cache_t eeprom_cache = {0xFF, {0}, 0};

// Индексы системных сообщений
typedef enum {
    MSG_FUCK_OFF = 0,
    MSG_WOW_NICE,
    MSG_AMAZING_BRIGHT,
    MSG_VERSION,
    MSG_EDIT_CELL,
    MSG_CELL,
    MSG_BRIGHTNESS_SHORT,
    MSG_BRIGHTNESS_FULL,
    MSG_SETUP,
    MSG_ERR_READ,
    MSG_ERR_OUT,
    MSG_COUNT
} message_id_t;

// Тексты системных сообщений
static const char messages[MSG_COUNT][32] = {
    [MSG_FUCK_OFF]         = "Отмена!",
    [MSG_WOW_NICE]         = "Сделал!",
    [MSG_AMAZING_BRIGHT]   = "Изменил!",
    [MSG_VERSION]          = PULTVERSION,
    [MSG_EDIT_CELL]        = "Ред яч:",
    [MSG_CELL]             = "Яч:",
    [MSG_BRIGHTNESS_SHORT] = " Ярк:",
    [MSG_BRIGHTNESS_FULL]  = "Яркость: ",
    [MSG_SETUP]            = "Уст:",
    [MSG_ERR_READ]         = "Err read",
    [MSG_ERR_OUT]          = "Err out"
};

// Поиск индекса символа в таблице CP1251
int find_cp1251_index(char c) {
    for (int i = 0; cp1251_chars[i] != 0; i++) {
        if (cp1251_chars[i] == (unsigned char)c) return i;
    }
    return 0; // если не найден — возвращаем пробел
}

// Кэшированное чтение EEPROM
error_code_t cached_eeprom_read_string(uint8_t index, char *buf) {
    if (!buf) return ERR_READ;
    
    // Всегда очищаем буфер перед заполнением
    memset(buf, ' ', 32);  // Увеличено до 32
    buf[32] = '\0';        // Увеличено до 32
    
    // Проверяем кэш
    if (eeprom_cache.valid && eeprom_cache.index == index) {
        safe_strncpy(buf, eeprom_cache.data, 32);  // Увеличено до 32
        int len = strlen(buf);
        for (int i = len; i < 32; i++) {  // Увеличено до 32
            buf[i] = ' ';
        }
        buf[32] = '\0';  // Увеличено до 32
        return ERR_OK;
    }
    
    // Читаем из EEPROM
    int err = eeprom_read_string_by_num(index, buf);
    if (err == 0) {
        // Сохраняем в кэш
        eeprom_cache.index = index;
        safe_strncpy(eeprom_cache.data, buf, 32);  // Увеличено до 32
        eeprom_cache.valid = 1;
        
        // Дополняем пробелами
        int len = strlen(buf);
        for (int i = len; i < 32; i++) {  // Увеличено до 32
            buf[i] = ' ';
        }
        buf[32] = '\0';  // Увеличено до 32
    }
    return (error_code_t)err;
}

// Сброс кэша EEPROM для указанного индекса
void invalidate_eeprom_cache(uint8_t index) {
    if (eeprom_cache.valid && eeprom_cache.index == index) {
        eeprom_cache.valid = 0;
    }
}

// Функции обновления времени последней активности
static inline void update_edit_activity_time(void) {
    last_edit_activity_time = ttms;
}

static inline void update_norm_mode_activity_time(void) {
    last_norm_mode_activity_time = ttms;
}

static inline void update_bright_activity_time(void) {
    last_bright_activity_time = ttms;
}

// Общая функция показа сообщения об отмене
static void show_cancel_message(void) {
    display_mode = SHOWMSG;
    max_selected_index_enc = MAXCELLEEPROMUSE;
    lcdClearViaChars();
    safe_strncpy(msg_text, messages[MSG_FUCK_OFF], sizeof(msg_text));
    msg_start_time = ttms;
    msg_active = 1;
}

// Проверка таймаутов - объединенная функция
void check_timeouts(void) {
    switch (display_mode) {
        case DEDITMODE:
            if (ttms - last_edit_activity_time > EDIT_TIMEOUT_MS) {
                selected_index_enc = current_sell_ed;
                show_cancel_message();
            }
            break;
            
        case DNORMMODE:
            if (ttms - last_norm_mode_activity_time > NORMMODE_TIMEOUT_MS) {
                display_mode = DSCREENSAVER;
                lcdClearViaChars();
            }
            break;
            
        case DBRIGHTMODE:
            if (ttms - last_bright_activity_time > EDIT_TIMEOUT_MS) {
                selected_index_enc = last_show_editing_cell;
                show_cancel_message();
            }
            break;
            
        default:
            break;
    }
}

// Общая функция выхода из скринсейвера
static inline void exit_screensaver(void) {
    display_mode = DNORMMODE;
    update_norm_mode_activity_time();
    lcdClearViaChars();
}

// Общая функция чтения и отображения ячейки EEPROM
static void read_and_display_cell(uint8_t cell_index) {
    char buf[33] = {0};  // Увеличено до 32 + терминатор
    error_code_t err = cached_eeprom_read_string(cell_index, buf);
    
    switch (err) {
        case ERR_READ:
            safe_strncpy(display_string, messages[MSG_ERR_READ], sizeof(display_string));
            break;
        case ERR_OUT:
            safe_strncpy(display_string, messages[MSG_ERR_OUT], sizeof(display_string));
            break;
        case ERR_OK:
        default:
            safe_strncpy(display_string, buf, sizeof(display_string));
            // Не обрезаем строку, так как работаем с полными 32 символами
            break;
    }
}

// Функция для получения отображаемой части строки
static void get_display_part(char *output) {
    if (display_part == 0) {
        // Первая часть строки (символы 0-15)
        safe_strncpy(output, display_string, 16);
    } else {
        // Вторая часть строки (символы 16-31)
        if (strlen(display_string) > 16) {
            safe_strncpy(output, display_string + 16, 16);
        } else {
            // Если строка короче 16 символов, показываем пустую вторую часть
            memset(output, ' ', 16);
            output[16] = '\0';
        }
    }
}

// Обработчики кнопок - оптимизированные версии

// Короткое нажатие кнопки 1
void btn_press_handler1(void) {
    if (display_mode == DSCREENSAVER) {
        exit_screensaver();
        return;
    }
    
    switch (display_mode) {
        case DEDITMODE:
            update_edit_activity_time();
            // Перемещаем позицию курсора влево с зацикливанием
            symbol_position = (symbol_position == 0) ? EDTSTRLEN - 1 : symbol_position - 1;
            new_char = editing_string[symbol_position];
            selected_index_enc = find_cp1251_index(new_char);
            break;
            
        case DNORMMODE:
            update_norm_mode_activity_time();
            // Перемещаемся к предыдущей ячейке EEPROM
            selected_index_enc = (selected_index_enc == 0) ? max_selected_index_enc - 1 : selected_index_enc - 1;
            read_and_display_cell(selected_index_enc);
            display_part = 0; // Сбрасываем к первой части при смене ячейки
            break;
            
        default:
            break;
    }
}

// Длинное нажатие кнопки 1
void btn_long_press_handler1(void) {
    if (display_mode == DSCREENSAVER) {
        exit_screensaver();
        return;
    }
    
    if (display_mode == DNORMMODE) {
        update_norm_mode_activity_time();
        
        // Вход в режим редактирования текущей отображаемой части
        current_sell_ed = selected_index_enc;
        display_mode = DEDITMODE;
        max_selected_index_enc = EDTMODMAXCNT;
        
        // Запоминаем, какую часть редактируем
        editing_part = display_part;
        
        // Подготовка строки для редактирования - берем соответствующую часть
        if (editing_part == 0) {
            // Редактируем первую часть (символы 0-15)
            safe_strncpy(editing_string, display_string, 16);
        } else {
            // Редактируем вторую часть (символы 16-31)
            if (strlen(display_string) > 16) {
                safe_strncpy(editing_string, display_string + 16, 16);
            } else {
                // Если строка короче 16 символов, начинаем с пустой второй части
                memset(editing_string, ' ', 16);
                editing_string[16] = '\0';
            }
        }
        
        trim_and_clean_string(editing_string, EDTSTRLEN);
        pad_string_with_spaces(editing_string, strlen(editing_string), EDTSTRLEN);
        
        // Установка начальной позиции редактирования
        symbol_position = 0;
        new_char = editing_string[symbol_position];
        selected_index_enc = find_cp1251_index(new_char);
        
        update_edit_activity_time();
        lcdClearViaChars();
    }
}

// Короткое нажатие кнопки 2
void btn_press_handler2(void) {
    if (display_mode == DSCREENSAVER) {
        exit_screensaver();
        return;
    }
    
    switch (display_mode) {
        case DEDITMODE:
            update_edit_activity_time();
            // Перемещаем позицию курсора вправо с зацикливанием
            symbol_position = (symbol_position >= EDTSTRLEN - 1) ? 0 : symbol_position + 1;
            new_char = editing_string[symbol_position];
            selected_index_enc = find_cp1251_index(new_char);
            break;
            
        case DNORMMODE:
            update_norm_mode_activity_time();
            // Перемещаемся к следующей ячейке EEPROM
            selected_index_enc = (selected_index_enc >= max_selected_index_enc - 1) ? 0 : selected_index_enc + 1;
            read_and_display_cell(selected_index_enc);
            display_part = 0; // Сбрасываем к первой части при смене ячейки
            break;
            
        default:
            break;
    }
}

// Длинное нажатие кнопки 2
void btn_long_press_handler2(void) {
    if (display_mode == DSCREENSAVER) {
        exit_screensaver();
        return;
    }
    
    if (display_mode == DNORMMODE) {
        update_norm_mode_activity_time();
        
        // Вход в режим настройки яркости
        display_mode = DBRIGHTMODE;
        max_selected_index_enc = MAX_BRIGHTNESS;
        last_show_editing_cell = selected_index_enc;
        selected_index_enc = brightness;
        
        update_bright_activity_time();
        lcdClearViaChars();
    }
}

// Короткое нажатие кнопки 3 - переключение между частями строки
void btn_press_handler3(void) {
    if (display_mode == DSCREENSAVER) {
        exit_screensaver();
        return;
    }
    
    if (display_mode == DNORMMODE) {
        update_norm_mode_activity_time();
        // Переключаем между первой и второй частью строки
        display_part = !display_part;
    }
}

// Длинное нажатие кнопки 3 не используется
void btn_long_press_handler3(void) {
    // Длинное нажатие кнопки 3 не используется
}

// Короткое нажатие кнопки 4 (Send, Ok)
void btn_press_handler4(void) {
    if (display_mode == DSCREENSAVER) {
        exit_screensaver();
        return;
    }
    
    switch (display_mode) {
        case DEDITMODE:
            update_edit_activity_time();
            // Сохранение отредактированной строки
            display_mode = SHOWMSG;
            max_selected_index_enc = MAXCELLEEPROMUSE;
            selected_index_enc = current_sell_ed;
            trim_and_clean_string(editing_string, EDTSTRLEN);
            
            // Сохраняем в соответствующую часть строки
            char temp_full_string[33] = {0};
            
            // Сначала читаем текущую полную строку из EEPROM
            if (cached_eeprom_read_string(selected_index_enc, temp_full_string) != ERR_OK) {
                // Если не удалось прочитать, используем текущий display_string
                safe_strncpy(temp_full_string, display_string, 32);
            }
            
            if (editing_part == 0) {
                // Сохраняем в первую часть (символы 0-15)
                // Копируем только 16 символов, не трогая остальные
                for (int i = 0; i < 16 && i < EDTSTRLEN; i++) {
                    temp_full_string[i] = editing_string[i];
                }
            } else {
                // Сохраняем во вторую часть (символы 16-31)
                for (int i = 0; i < 16 && i < EDTSTRLEN; i++) {
                    temp_full_string[16 + i] = editing_string[i];
                }
            }
            
            // Гарантируем, что строка имеет правильную длину
            temp_full_string[32] = '\0';
            
            eeprom_write_string_by_num(selected_index_enc, temp_full_string);
            invalidate_eeprom_cache(selected_index_enc);
            
            // Обновляем display_string для отображения
            safe_strncpy(display_string, temp_full_string, 32);
            display_string[32] = '\0';
            
            lcdClearViaChars();
            safe_strncpy(msg_text, messages[MSG_WOW_NICE], sizeof(msg_text));
            msg_start_time = ttms;
            msg_active = 1;
            break;
            
        case DNORMMODE:
            update_norm_mode_activity_time();
            // Отправка данных через RS485 - отправляем полную строку
            rs485_send_string_with_params(brightness, '#', '#', cp1251_to_utf8_alloc(display_string));
            eeprom_write_uint16_by_num(EELASTUSEDCELL, selected_index_enc);
            break;
            
        case DBRIGHTMODE:
            update_bright_activity_time();
            // Сохранение новой настройки яркости
            brightness = selected_index_enc;
            display_mode = SHOWMSG;
            max_selected_index_enc = MAXCELLEEPROMUSE;
            selected_index_enc = (selected_index_enc > max_selected_index_enc) ? 0 : last_show_editing_cell;
            eeprom_write_uint16_by_num(EEBRIGHTNESS, brightness);
            lcdClearViaChars();
            safe_strncpy(msg_text, messages[MSG_AMAZING_BRIGHT], sizeof(msg_text));
            msg_start_time = ttms;
            msg_active = 1;
            break;
            
        default:
            break;
    }
}

// Длинное нажатие кнопки 4 не используется 
void btn_long_press_handler4(void) {}

// Короткое нажатие кнопки 5 (Send)
void btn_press_handler5(void) {
    if (display_mode == DSCREENSAVER) {
        exit_screensaver();
        return;
    }
    
    if (display_mode == DNORMMODE) {
        update_norm_mode_activity_time();
    }
    eeprom_clear_all_strings();
    // Отправка данных через RS485
    rs485_send_string_with_params(brightness, '#', '#', cp1251_to_utf8_alloc(display_string));
    eeprom_write_uint16_by_num(EELASTUSEDCELL, selected_index_enc);
}

// Длинное нажатие кнопки 5 не используется
void btn_long_press_handler5(void) {}

// Переменные для управления обновлением дисплея
static display_mode_t last_display_mode = (display_mode_t)0xFF;
volatile uint8_t force_display_update = 0;

// Основная функция отрисовки интерфейса
void display_process(void) {
    if (lcdms > ttms || ttms - lcdms > 20) {
        // Проверяем изменение режима для полной перерисовки
        if (display_mode != last_display_mode) {
            lcdClear();
            last_display_mode = display_mode;
            force_display_update = 0;
        }
        
        // Проверяем таймауты
        check_timeouts();
        
        switch (display_mode) {
            case SHOWMSG:
                // Обработка режима показа сообщений
                if (msg_active == 0) {
                    msg_start_time = ttms;
                    msg_active = 1;
                }
                if (ttms - msg_start_time > MSGSHOWTNS) {
                    // Возврат в нормальный режим после показа сообщения
                    msg_active = 0;
                    display_mode = DNORMMODE;
                    update_norm_mode_activity_time();
                    lcdClear();
                    cached_eeprom_read_string(selected_index_enc, display_string);
                    lcdString16(display_string, 1);
                    lcdms = ttms - 21; // Принудительное обновление на следующем цикле
                } else {
                    // Показ сообщения
                    lcdSetCursorB(0, 0, 0);
                    lcdPrintUtf8(msg_text, 0);
                }
                break;
                
            case DEDITMODE:
                // Режим редактирования - отображаем редактируемую часть
                lcdSetCursor(0, 0);
                lcdPrintUtf8(messages[MSG_EDIT_CELL], 0);
                lcdPrintTwoDigitNumber(current_sell_ed);
                
                // Показываем какую часть редактируем
                if (editing_part == 0) {
                    lcdPrintUtf8("(1)", 0);
                } else {
                    lcdPrintUtf8("(2)", 0);
                }
                
                lcdString16(editing_string, 1);
                lcdSetCursorN(symbol_position, 1, 2);
                break;
                
            case DNORMMODE:
                // Нормальный режим - отображаем текущую часть строки
                lcdSetCursor(0, 0);
                lcdPrintUtf8(messages[MSG_CELL], 0);
                lcdPrintTwoDigitNumber(selected_index_enc);
                lcdPrintUtf8(messages[MSG_BRIGHTNESS_SHORT], 0);
                lcdPrintTwoDigitNumber(brightness);
                
                // Отображаем текущую часть строки
                char current_part[17] = {0};
                get_display_part(current_part);
                lcdString16(current_part, 1);
                
                // Показываем индикатор части строки
                lcdSetCursor(15, 0);
                if (display_part == 0) {
                    lcdData('.');
                } else {
                    lcdData(':');
                }
                break;
                
            case DBRIGHTMODE:
                // Режим настройки яркости
                lcdSetCursor(0, 0);
                lcdPrintUtf8(messages[MSG_BRIGHTNESS_FULL], 0);
                lcdPrintTwoDigitNumber(selected_index_enc);
                break;
                
            case DSETUPMODE:
                // Режим настройки (заглушка)
                lcdSetCursor(0, 0);
                lcdPrintUtf8(messages[MSG_SETUP], 0);
                break;
                
            case DSCREENSAVER:
                // Режим скринсейвера - показ случайных символов
                show_screensaver();
                break;
        }
        lcdms = ttms;
    }
}

// Обработчик вращения энкодера
void my_encoder_handler(uint8_t new_value, int8_t direction) {
    switch (display_mode) {
        case DEDITMODE:
            update_edit_activity_time();
            // Изменение символа в режиме редактирования
            if (selected_index_enc >= sizeof(cp1251_chars) - 1) {
                selected_index_enc = 0;
            }
            new_char = cp1251_chars[selected_index_enc];
            replace_char_at(editing_string, symbol_position, new_char, EDTSTRLEN);
            break;
            
        case DNORMMODE:
            update_norm_mode_activity_time();
            read_and_display_cell(selected_index_enc);
            break;
            
        case DBRIGHTMODE:
            update_bright_activity_time();
            // Обработка настройки яркости (энкодер изменяет selected_index_enc)
            break;
            
        case DSETUPMODE:
        default:
            // Обработка других режимов
            break;
    }
}

// Главная функция
int main(void) {
    // Инициализация системы
    StartHSE();
    hardware_init();
    i2c1init();
    
    delay_ms(20);
    lcd_init();
    delay_ms(20);
    lcd_init();
    delay_ms(20);
    lcd_init();

    // Инициализация периферии
    encoder_init();
    encoder_callback = my_encoder_handler;
    buttons_init();
    
    // Инициализация генератора случайных чисел
    simple_srand(ttms);
    
    // Загрузка сохраненных настроек
    uint16_t tmp;
    if (eeprom_read_uint16_by_num(EEBRIGHTNESS, &tmp) == 0 && tmp <= MAX_BRIGHTNESS) {
        brightness = (uint8_t)tmp;
    }
    if (eeprom_read_uint16_by_num(EELASTUSEDCELL, &tmp) == 0 && tmp < MAXCELLEEPROMUSE) {
        selected_index_enc = (uint8_t)tmp;
    }
    
    // Загрузка и подготовка строки для отображения
    cached_eeprom_read_string(selected_index_enc, display_string);
    
    // Инициализация времени активности
    update_norm_mode_activity_time();
    update_bright_activity_time();
    delay_ms(10);
    // Инициализация RS485
    rs485_init(4800);
    delay_ms(15);
    
    // Показ версии и начальная инициализация
    lcdPrintUtf8(messages[MSG_VERSION], 0);
    delay_ms(1500);
    lcdClearViaChars();
    
    // Проверка кнопки для входа в режим настройки
    if (!(GPIOB->IDR & GPIO_IDR_IDR14)) {
        display_mode = DSETUPMODE;
    }
    
    // Отправка начальных данных и сохранение состояния
    rs485_send_string_with_params(brightness, '#', '#', cp1251_to_utf8_alloc(display_string));
    eeprom_write_uint16_by_num(EELASTUSEDCELL, selected_index_enc);
    iwdg_setup();

    // Основной цикл программы
    while (1) {
        display_process();   // Обработка отображения
        // Колбек энкодера идёт из SysTick в common.c
        blink_pc14led(1000);
        IWDG->KR = IWDG_REFRESH; // refresh watchdog
    }
}     eeprom.c: #include "eeprom.h"
#include "stm32f10x.h"

#define EEPROM_SIZE 4096
#define STRING_SIZE 32        // Изменено с 16 на 32
#define MAX_STRINGS 100       // Изменено с 200 на 100
#define VAR_UINT16_COUNT 20
#define EEPROM_PAGE_SIZE 32
#define WAITCNT 5000

#ifndef NULL
#define NULL ((void *)0)
#endif

// Простая программная задержка (примерно)
void delay_simple(uint32_t count) {
  while (count--) {
    __NOP();    // asm nop для небольшого замедления
  }
}

int I2C_WaitEvent(uint32_t event) {
  uint32_t timeout = WAITCNT;
  while (!(I2C1->SR1 & event)) {
    if (--timeout == 0)
      return 0;
  }
  return 1;
}

// Запись байта в EEPROM
int eeprom_write_byte(uint16_t addr, uint8_t data) {
  while (I2C1->SR2 & I2C_SR2_BUSY);

  I2C1->CR1 |= I2C_CR1_START;
  if (!I2C_WaitEvent(I2C_SR1_SB)) return -1;

  I2C1->DR = EEPROM_ADDR;
  if (!I2C_WaitEvent(I2C_SR1_ADDR)) return -1;
  (void)I2C1->SR2;

  I2C1->DR = (addr >> 8) & 0xFF;
  if (!I2C_WaitEvent(I2C_SR1_TXE)) return -1;

  I2C1->DR = addr & 0xFF;
  if (!I2C_WaitEvent(I2C_SR1_TXE)) return -1;

  I2C1->DR = data;
  if (!I2C_WaitEvent(I2C_SR1_TXE)) return -1;

  I2C1->CR1 |= I2C_CR1_STOP;
  // Простейшая задержка для записи EEPROM
  delay_simple(WAITCNT);
  return 0;
}

// Запись страницы в EEPROM (последовательная запись нескольких байт)
int eeprom_write_page(uint16_t addr, uint8_t *data, uint16_t len) {
  if (len == 0) return 0;
  
  // Проверяем, чтобы запись не выходила за границу страницы
  uint16_t page_boundary = (addr / EEPROM_PAGE_SIZE + 1) * EEPROM_PAGE_SIZE;
  if (addr + len > page_boundary) {
    len = page_boundary - addr;  // Ограничиваем длину записи
  }

  while (I2C1->SR2 & I2C_SR2_BUSY);

  I2C1->CR1 |= I2C_CR1_START;
  if (!I2C_WaitEvent(I2C_SR1_SB)) return -1;

  I2C1->DR = EEPROM_ADDR;
  if (!I2C_WaitEvent(I2C_SR1_ADDR)) return -1;
  (void)I2C1->SR2;

  I2C1->DR = (addr >> 8) & 0xFF;
  if (!I2C_WaitEvent(I2C_SR1_TXE)) return -1;

  I2C1->DR = addr & 0xFF;
  if (!I2C_WaitEvent(I2C_SR1_TXE)) return -1;

  // Записываем все байты страницы
  for (uint16_t i = 0; i < len; i++) {
    I2C1->DR = data[i];
    if (!I2C_WaitEvent(I2C_SR1_TXE)) return -1;
  }

  I2C1->CR1 |= I2C_CR1_STOP;
  // Задержка для записи страницы (может быть больше чем для одного байта)
  delay_simple(WAITCNT);
  return 0;
}

// Чтение байта из EEPROM
int eeprom_read_byte(uint16_t addr, uint8_t *data) {
  while (I2C1->SR2 & I2C_SR2_BUSY);

  I2C1->CR1 |= I2C_CR1_START;
  if (!I2C_WaitEvent(I2C_SR1_SB)) return -1;

  I2C1->DR = EEPROM_ADDR;
  if (!I2C_WaitEvent(I2C_SR1_ADDR)) return -1;
  (void)I2C1->SR2;

  I2C1->DR = (addr >> 8) & 0xFF;
  if (!I2C_WaitEvent(I2C_SR1_TXE)) return -1;

  I2C1->DR = addr & 0xFF;
  if (!I2C_WaitEvent(I2C_SR1_TXE)) return -1;

  I2C1->CR1 |= I2C_CR1_START;
  if (!I2C_WaitEvent(I2C_SR1_SB)) return -1;

  I2C1->DR = EEPROM_ADDR | 1;
  if (!I2C_WaitEvent(I2C_SR1_ADDR)) return -1;
  (void)I2C1->SR2;

  I2C1->CR1 &= ~I2C_CR1_ACK;

  if (!I2C_WaitEvent(I2C_SR1_RXNE)) return -1;

  *data = I2C1->DR;

  I2C1->CR1 |= I2C_CR1_STOP;
  I2C1->CR1 |= I2C_CR1_ACK;

  return 0;
}

// Чтение страницы из EEPROM (последовательное чтение нескольких байт)
int eeprom_read_page(uint16_t addr, uint8_t *data, uint16_t len) {
  if (len == 0) return 0;

  while (I2C1->SR2 & I2C_SR2_BUSY);

  I2C1->CR1 |= I2C_CR1_START;
  if (!I2C_WaitEvent(I2C_SR1_SB)) return -1;

  I2C1->DR = EEPROM_ADDR;
  if (!I2C_WaitEvent(I2C_SR1_ADDR)) return -1;
  (void)I2C1->SR2;

  I2C1->DR = (addr >> 8) & 0xFF;
  if (!I2C_WaitEvent(I2C_SR1_TXE)) return -1;

  I2C1->DR = addr & 0xFF;
  if (!I2C_WaitEvent(I2C_SR1_TXE)) return -1;

  I2C1->CR1 |= I2C_CR1_START;
  if (!I2C_WaitEvent(I2C_SR1_SB)) return -1;

  I2C1->DR = EEPROM_ADDR | 1;
  if (!I2C_WaitEvent(I2C_SR1_ADDR)) return -1;
  (void)I2C1->SR2;

  // Читаем несколько байт последовательно
  for (uint16_t i = 0; i < len; i++) {
    if (i == len - 1) {
      // Для последнего байта отправляем NACK
      I2C1->CR1 &= ~I2C_CR1_ACK;
    } else {
      // Для всех кроме последнего отправляем ACK
      I2C1->CR1 |= I2C_CR1_ACK;
    }

    if (!I2C_WaitEvent(I2C_SR1_RXNE)) return -1;
    data[i] = I2C1->DR;
  }

  I2C1->CR1 |= I2C_CR1_STOP;
  I2C1->CR1 |= I2C_CR1_ACK;  // Восстанавливаем ACK для следующих операций

  return 0;
}

// Записывает строку в EEPROM (постраничная запись)
// addr Начальный адрес для записи
// str Указатель на строку (максимум 31 символ + терминатор)
// ret 0 в случае успеха, -1 при ошибке
int eeprom_write_string(uint16_t addr, const char *str) {
  uint8_t buffer[STRING_SIZE] = {0};
  uint16_t i = 0;

  // Копируем строку в буфер
  while (i < STRING_SIZE - 1 && str[i] != '\0') {
    buffer[i] = (uint8_t)str[i];
    i++;
  }
  
  // Гарантируем нулевой терминатор
  buffer[i] = '\0';

  // Записываем всю строку одной страницей
  return eeprom_write_page(addr, buffer, STRING_SIZE);
}

// Читает строку из EEPROM (постраничное чтение)
// addr Начальный адрес для чтения
// str Буфер для строки (минимум 32 байт)
// ret 0 в случае успеха, -1 при ошибке
int eeprom_read_string(uint16_t addr, char *str) {
  uint8_t buffer[STRING_SIZE];

  // Читаем всю строку одной страницей
  if (eeprom_read_page(addr, buffer, STRING_SIZE) != 0) {
    return -1;    // Ошибка чтения
  }

  // Копируем данные в буфер строки
  for (uint16_t i = 0; i < STRING_SIZE; i++) {
    str[i] = (char)buffer[i];
    if (buffer[i] == '\0') {
      break;    // Встретили терминатор - выходим
    }
  }

  // Гарантируем, что строка всегда заканчивается терминатором
  str[STRING_SIZE - 1] = '\0';
  return 0;    // Успех
}

// Адрес начала блока переменных uint16_t
#define VARS_START_ADDR (MAX_STRINGS * STRING_SIZE)    // 100 * 32 = 3200

// Записывает строку длиной до 31 символов + терминатор в EEPROM по номеру строки (0..MAX_STRINGS-1)
// string_num Номер строки (0..MAX_STRINGS-1)
// str Строка для записи
// ret 0 — успех, -1 — ошибка записи, -2 — номер строки вне диапазона
int eeprom_write_string_by_num(uint16_t string_num, const char *str) {
  if (string_num >= MAX_STRINGS) return -2;

  uint16_t addr = string_num * STRING_SIZE;
  uint8_t buffer[STRING_SIZE] = {0};  // Инициализируем нулями

  // Копируем строку в буфер
  uint16_t i = 0;
  while (i < STRING_SIZE - 1 && str[i] != '\0') {
    buffer[i] = (uint8_t)str[i];
    i++;
  }
  // buffer[i] уже 0 из-за инициализации

  // Записываем всю строку одной страницей
  return eeprom_write_page(addr, buffer, STRING_SIZE);
}

// Чтение строки по номеру с постраничным чтением
// string_num Номер строки (0..MAX_STRINGS-1)
// str Буфер для строки (минимум STRING_SIZE байт)
// ret 0 — успех, -1 — ошибка чтения, -2 — номер строки вне диапазона
int eeprom_read_string_by_num(uint16_t string_num, char *str) {
  if (str == NULL) return -1;    // Проверка указателя
  if (string_num >= MAX_STRINGS) return -2;    // Проверка диапазона

  uint16_t addr = string_num * STRING_SIZE;
  uint8_t buffer[STRING_SIZE];

  // Читаем всю строку одной страницей
  if (eeprom_read_page(addr, buffer, STRING_SIZE) != 0) {
    str[0] = '\0';  // Завершаем строку при ошибке чтения
    return -1;
  }

  // Обрабатываем прочитанные данные
  uint16_t i;
  for (i = 0; i < STRING_SIZE - 1; i++) {    // Оставляем место для терминатора
    // ЗАМЕНА 0xFF на пробел
    if (buffer[i] == 0xFF) { 
      str[i] = ' '; 
    } else { 
      str[i] = (char)buffer[i]; 
    }

    if (buffer[i] == '\0') break;    // Нашли конец строки
  }
  
  // Если не нашли '\0' - принудительно ставим в конце
  str[i] = '\0';
  return 0;
}

// Очищает строку в EEPROM (записывает все байты как 0xFF)
// string_num Номер строки (0..MAX_STRINGS-1)
// ret 0 — успех, -1 — ошибка записи, -2 — номер строки вне диапазона
int eeprom_clear_string(uint16_t string_num) {
  if (string_num >= MAX_STRINGS) return -2;

  uint16_t addr = string_num * STRING_SIZE;
  
  // Очищаем побайтово - это надежнее для EEPROM
  for (uint16_t i = 0; i < STRING_SIZE; i++) {
    if (eeprom_write_byte(addr + i, 0xFF) != 0) {
      return -1;
    }
    // Небольшая задержка между байтами
    delay_simple(1000);
  }
  
  return 0;
}

// Проверяет, есть ли данные в строке (не все байты 0xFF)
// string_num Номер строки (0..MAX_STRINGS-1)
// ret 1 — данные есть, 0 — пусто, -1 — ошибка чтения, -2 — номер строки вне диапазона
int eeprom_is_string_used(uint16_t string_num) {
  if (string_num >= MAX_STRINGS) return -2;

  uint16_t addr = string_num * STRING_SIZE;
  uint8_t buffer[STRING_SIZE];

  // Используем постраничное чтение для проверки
  if (eeprom_read_page(addr, buffer, STRING_SIZE) != 0)
    return -1;

  for (uint16_t i = 0; i < STRING_SIZE; i++) {
    if (buffer[i] != 0xFF)
      return 1;    // Найден непустой байт
  }
  return 0;        // Все байты пустые (0xFF)
}

// Полностью очищает все строки (записывает 0xFF)
// ret 0 — успех, -1 — ошибка записи
int eeprom_clear_all_strings(void) {
  // Очищаем каждую строку отдельно с задержками
  for (uint16_t i = 0; i < MAX_STRINGS; i++) {
    if (eeprom_clear_string(i) != 0) {
      return -1;
    }
    // Задержка между строками
    delay_simple(5000);
  }
  return 0;
}

// Записывает uint16_t переменную в EEPROM по номеру (1..20)
// var_num Номер переменной (1..20)
// value Значение для записи
// ret 0 — успех, -1 — ошибка записи, -2 — номер вне диапазона
int eeprom_write_uint16_by_num(uint16_t var_num, uint16_t value) {
  if (var_num == 0 || var_num > VAR_UINT16_COUNT) return -2;

  uint16_t addr = VARS_START_ADDR + (var_num - 1) * 2;
  uint8_t buffer[2] = {(uint8_t)(value & 0xFF), (uint8_t)((value >> 8) & 0xFF)};

  // Записываем оба байта одной страницей
  return eeprom_write_page(addr, buffer, 2);
}

// Читает uint16_t переменную из EEPROM по номеру (1..20)
// var_num Номер переменной (1..20)
// value Указатель для сохранения результата
// ret 0 — успех, -1 — ошибка чтения, -2 — номер вне диапазона
int eeprom_read_uint16_by_num(uint16_t var_num, uint16_t *value) {
  if (var_num == 0 || var_num > VAR_UINT16_COUNT) return -2;

  uint16_t addr = VARS_START_ADDR + (var_num - 1) * 2;
  uint8_t buffer[2];

  // Читаем оба байта одной страницей
  if (eeprom_read_page(addr, buffer, 2) != 0) return -1;

  *value = ((uint16_t)buffer[1] << 8) | buffer[0];
  return 0;
}

// Очищает все 20 переменных (записывает 0xFFFF)
// ret 0 — успех, -1 — ошибка записи
int eeprom_clear_all_uint16_vars(void) {
  // Очищаем каждую переменную отдельно
  for (uint16_t i = 1; i <= VAR_UINT16_COUNT; i++) {
    uint16_t addr = VARS_START_ADDR + (i - 1) * 2;
    
    // Записываем 0xFF в каждый байт
    if (eeprom_write_byte(addr, 0xFF) != 0) return -1;
    delay_simple(1000);
    
    if (eeprom_write_byte(addr + 1, 0xFF) != 0) return -1;
    delay_simple(1000);
  }
  return 0;
}

// Eof eeprom.c       Редактируются строка в 32 символа и сохраняется в 24C32, отображается на экане Мэлт 1602, при редактировании первой половины обнуляется вторая половина. Нужны ли все нуль-терминаторы, может убрать? 
Также убрать скринсейвер.
main.c целиком переписать, и нужно всё делать аккуратно!